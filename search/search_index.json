{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Concept","text":"<p>There are three popular repositories of Philippine Supreme Court decisions. Reference to such decisions are (traditionally) based on the name of the repository.</p> <p>Two of which - <code>Phil.</code> and <code>SCRA</code> - are talked about in the case of China Airlines v. Chiok, G.R. No. 152122, July 30, 2003:</p> <p>x x x This Court hereby exhorts members of the bar and the bench to refer to and quote from the official repository of our decisions, the Philippine Reports, whenever practicable [footnote: In the present case, Philippine Reports are cited whenever possible.]. In the absence of this primary source, which is still being updated, they may resort to unofficial sources like the SCRA [footnote: Supreme Court Reports Annotated]. We remind them that the Court\u2019s ponencia, when used to support a judgment or ruling, should be quoted accurately. (emphasis and footnotes supplied)</p>"},{"location":"#repositories","title":"Repositories","text":"Style Nature Publisher Description Basis <code>Phil.</code> Public Philippine Reports Though \"official\", often delayed in publication The [Supreme Court] Reporter shall prepare and publish with each reported decision a concise synopsis of the facts necessary to a clear understanding of the case x x x <code>Offg.</code> Public Official Gazette Though \"official\", decisions are only published here occasionally There shall be published in the Official Gazette all x x x decisions or abstracts of decisions of the Supreme Court and the Court of Appeals, or other courts of similar rank, as may be deemed by the said courts of sufficient importance to be so published; x x x <code>SCRA</code> Private Supreme Court Reports Annotated An unofficial source but more frequently printed by private entity See disquisition in China Airlines v. Chiok (2003)"},{"location":"#purpose","title":"Purpose","text":"<p>Each of the Report sources have the same format, differing only in the <code>publisher</code> involved.  Its necessary to create a uniform style because of inconsistent styling over the years.</p> Volume Uniform Publisher Page/s Date Sample Inconsistencies Volume no. Name / style of the publisher / reporter Page number/s of the volume Optional date 1 Phil. Reports 100 is equivalent to 1 Phil. 100 1 <code>Phil.</code> 100 - 100 S.C.R.A. 105, 101-103 (1994) is equivalent to 100 SCRA 105 1 <code>SCRA</code> 105 - 41 Off. Gazette 1001, Jan. 1, 1949 is equivalent to 41 O.G. 1001 41 <code>O.G.</code> 1001 Jan. 1, 1949 <p>This library takes advantage of regex to detect patterns of citations and outputs a uniform dissection of the same based on the table above. See:</p> <ol> <li>Publisher Styles: <code>Phil.</code>, <code>SCRA</code> and <code>O.G.</code></li> <li>Report Object: Publisher styles with their accompanying digits, i.e. volume and page numbers</li> </ol>"},{"location":"patterns/","title":"Patterns","text":""},{"location":"patterns/#general-usage","title":"General Usage","text":"Python<pre><code>&gt;&gt;&gt; from citation_report import REPORT_PATTERN\n&gt;&gt;&gt; text = \"42 SCRA 109, 117-118, October 29, 1971;\"\n&gt;&gt;&gt; match = REPORT_PATTERN.search(text)\n&gt;&gt;&gt; match.group(\"volpubpage\")\n'42 SCRA 109'\n&gt;&gt;&gt; match.group(\"volume\")\n'42 SCRA 109'\n&gt;&gt;&gt; match.group(\"publisher\")\n'SCRA'\n&gt;&gt;&gt; match.group(\"page\")\n'109'\n&gt;&gt;&gt; match.group(\"report_date\")\n'October 29, 1971'\n</code></pre>"},{"location":"patterns/#typographic-error-patterns","title":"Typographic Error Patterns","text":"Python<pre><code>&gt;&gt;&gt; from citation_report import REPORT_PATTERN\n&gt;&gt;&gt; text = \"1aPhil3\" #  Won't work\n&gt;&gt;&gt; assert REPORT_PATTERN.search(text) is None\n&gt;&gt;&gt; modified_text = \"1a Phil 3\"\n&gt;&gt;&gt; match = REPORT_PATTERN.search(modified_text)\n&gt;&gt;&gt; match.group(\"volume\")\n'1a'\n&gt;&gt;&gt; match.group(\"publisher\")\n'Phil.'\n&gt;&gt;&gt; match.group(\"page\")\n'3'\n</code></pre>"},{"location":"publisher/","title":"Publisher","text":""},{"location":"publisher/#citation_report.publisher.PublisherStyle","title":"<code>PublisherStyle</code>","text":"<p>         Bases: <code>BaseModel</code></p> <p>Each publisher is represented by a regex expression <code>regex</code>. The <code>group_name</code> should be present in the <code>regex</code>.</p> Source code in <code>citation_report/publisher.py</code> Python<pre><code>class PublisherStyle(BaseModel):\n\"\"\"Each publisher is represented by a regex expression `regex`.\n    The `group_name` should be present in the `regex`.\n    \"\"\"\nlabel: str = Field(\n...,\ntitle=\"Report style\",\ndescription=\"Use for uniformity\",\n)\ngroup_name: str = Field(\n...,\ntitle=\"Regex group name\",\ndescription=\"Custom regex group that identifies the publisher\",\n)\nregex: str = Field(\n...,\ntitle=\"Regular expression\",\ndescription=(\n\"The regex expression that can be used to extract the various\"\n\" publisher styles, e.g. 'Phil.' or 'Phil. Report', 'SCRA' or\"\n\" 'S.C.R.A. Note that all expressions are eventually combined in\"\n\" `REPORT_PATTERN`.\"\n),\n)\n@property\ndef pattern(self) -&gt; Pattern:\nreturn re.compile(self.regex, re.I | re.X)\n</code></pre>"},{"location":"publisher/#citation_report.publisher.get_publisher_label","title":"<code>get_publisher_label(match)</code>","text":"<p>Given a regex match object from <code>published_report.REPORT_PATTERN</code>, determine if it contains a group name representing a Report publisher.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from citation_report import REPORT_PATTERN, get_publisher_label\n&gt;&gt;&gt; assert REPORT_PATTERN.search(\"124Phil.1241 statement\") is None\n&gt;&gt;&gt; sample = \"This is an example 124 Phil. 1241 statement\"\n&gt;&gt;&gt; m = REPORT_PATTERN.search(sample)\n&gt;&gt;&gt; m\n&lt;re.Match object; span=(19, 33), match='124 Phil. 1241'&gt;\n&gt;&gt;&gt; label = get_publisher_label(m)\n&gt;&gt;&gt; label\n'Phil.'\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>match</code> <code>Match</code> <p>Based on a prior <code>re.search</code> or <code>re.finditer</code> result on text</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: The first matching publisher found</p> Source code in <code>citation_report/publisher.py</code> Python<pre><code>def get_publisher_label(match: Match) -&gt; str | None:\n\"\"\"Given a regex match object from `published_report.REPORT_PATTERN`,\n    determine if it contains a group name representing a Report publisher.\n    Examples:\n        &gt;&gt;&gt; from citation_report import REPORT_PATTERN, get_publisher_label\n        &gt;&gt;&gt; assert REPORT_PATTERN.search(\"124Phil.1241 statement\") is None\n        &gt;&gt;&gt; sample = \"This is an example 124 Phil. 1241 statement\"\n        &gt;&gt;&gt; m = REPORT_PATTERN.search(sample)\n        &gt;&gt;&gt; m\n        &lt;re.Match object; span=(19, 33), match='124 Phil. 1241'&gt;\n        &gt;&gt;&gt; label = get_publisher_label(m)\n        &gt;&gt;&gt; label\n        'Phil.'\n    Args:\n        match (Match): Based on a prior `re.search` or `re.finditer`\n            result on text\n    Returns:\n        str | None: The first matching publisher found\n    \"\"\"\nfor src in [PHIL, SCRA, OFFG]:\nif match.group(src.group_name):\nreturn src.label\n</code></pre>"},{"location":"report/","title":"Report","text":""},{"location":"report/#citation_report.__main__.Report","title":"<code>Report</code>","text":"<p>         Bases: <code>BaseModel</code></p> <p>Pre-defined regex group names will enable the extraction of the Report's fields.</p> <p>It's important that each field be optional since the class is going to be joined to another <code>BaseModel</code> object, i.e. the <code>Docket</code>.</p> <p>In other words, the <code>Report</code> object is only one part of the <code>Citation</code> object. It's possible for a <code>Citation</code> object to:</p> <ol> <li>have both a <code>Docket</code> and a <code>Report</code>,</li> <li>have just a <code>Docket</code>;</li> <li>have just a <code>Report</code>.</li> </ol> <p>The reason for optional fields is to take these scenarios into account using the same model.</p> Source code in <code>citation_report/__main__.py</code> Python<pre><code>class Report(BaseModel):\n\"\"\"Pre-defined regex group names will enable the extraction\n    of the Report's fields.\n    It's important that each field be\n    optional since the class is going to be joined to another\n    `BaseModel` object, i.e. the `Docket`.\n    In other words, the `Report` object is only one part of\n    the `Citation` object. It's possible for a `Citation` object to:\n    1. have both a `Docket` and a `Report`,\n    2. have just a `Docket`;\n    3. have just a `Report`.\n    The reason for optional fields is to take these scenarios into account\n    using the same model.\n    \"\"\"\npublisher: str | None = Field(None, title=\"Type of the publisher.\")\nvolume: str | None = Field(None, title=\"Publisher volume number.\")\npage: str | None = Field(None, title=\"Publisher volume page.\")\nvolpubpage: str | None = Field(None, title=\"Combined fields.\")\nreport_date: datetime.date | None = None\ndef __str__(self) -&gt; str:\nreturn self.volpubpage or \"\"\n@property\ndef phil(self):\nreturn self.volpubpage if self.publisher == PHIL.label else None\n@property\ndef scra(self):\nreturn self.volpubpage if self.publisher == SCRA.label else None\n@property\ndef offg(self):\nreturn self.volpubpage if self.publisher == OFFG.label else None\n@classmethod\ndef extract_report(cls, text: str) -&gt; Iterator[Self]:\n\"\"\"Given sample legalese `text`, extract all Supreme Court `Report` patterns.\n        Examples:\n            &gt;&gt;&gt; sample = \"250 Phil. 271, 271-272, Jan. 1, 2019\"\n            &gt;&gt;&gt; report = next(Report.extract(sample))\n            &gt;&gt;&gt; type(report)\n            citation_report.__main__.Report\n            &gt;&gt;&gt; report.volpubpage\n            '250 Phil. 271'\n        Args:\n            text (str): Text containing report citations.\n        Yields:\n            Iterator[Self]: Iterator of `Report` instances\n        \"\"\"\nfor match in REPORT_PATTERN.finditer(text):\nreport_date = None\nif text := match.group(\"report_date\"):\ntry:\nreport_date = parse(text).date()\nexcept Exception:\nreport_date = None\npublisher = get_publisher_label(match)\nvolume = match.group(\"volume\")\npage = match.group(\"page\")\nif publisher and volume and page:\nyield Report(\npublisher=publisher,\nvolume=volume,\npage=page,\nvolpubpage=match.group(\"volpubpage\"),\nreport_date=report_date,\n)\n@classmethod\ndef extract_from_dict(cls, data: dict, report_type: str) -&gt; str | None:\n\"\"\"Assuming a dictionary with any of the following report_type keys\n        `scra`, `phil` or `offg`, get the value of the Report property.\n        Examples:\n            &gt;&gt;&gt; sample_data = {\"scra\": \"14 SCRA 314\"} # dict\n            &gt;&gt;&gt; Report.extract_from_dict(sample_data, \"scra\")\n            '14 SCRA 314'\n        Args:\n            data (dict): A `dict` containing a possible report `{key: value}`\n            report_type (str): Must be either \"scra\", \"phil\", or \"offg\"\n        Returns:\n            str | None: The value of the key `report_type` in the `data` dict.\n        \"\"\"\nif report_type.lower() in [\"scra\", \"phil\", \"offg\"]:\nif candidate := data.get(report_type):\ntry:\nobj = next(cls.extract_report(candidate))\n# will get the @property of the Report with the same name\nif hasattr(obj, report_type):\nreturn obj.__getattribute__(report_type)\nexcept StopIteration:\nreturn None\nreturn None\n@classmethod\ndef get_unique(cls, text: str) -&gt; list[str]:\n\"\"\"Will only get `Report` volpubpages (string) from the text. This\n        is used later in `citation_utils` to prevent duplicate citations.\n        Examples:\n            &gt;&gt;&gt; text = \"(22 Phil. 303; 22 Phil. 303; 176 SCRA 240; Pe\u00f1alosa v. Tuason, 22 Phil. 303, 313 (1912); Heirs of Roxas v. Galido, 108 Phil. 582 (1960)); Valmonte v. PCSO, supra; Bugnay Const. and Dev. Corp. v. Laron, 176 SCRA 240 (1989)\"\n            &gt;&gt;&gt; Report.get_unique(text)\n            ['22 Phil. 303', '108 Phil. 582', '176 SCRA 240']\n        Args:\n            text (str): Text to search for report patterns\n        Returns:\n            list[str]: Unique report `volpubpage` strings found in the text\n        \"\"\"  # noqa: E501\nreturn list(\n{r.volpubpage for r in cls.extract_report(text) if r.volpubpage}\n)\n</code></pre>"},{"location":"report/#citation_report.__main__.Report.extract_from_dict","title":"<code>extract_from_dict(data, report_type)</code>  <code>classmethod</code>","text":"<p>Assuming a dictionary with any of the following report_type keys <code>scra</code>, <code>phil</code> or <code>offg</code>, get the value of the Report property.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; sample_data = {\"scra\": \"14 SCRA 314\"} # dict\n&gt;&gt;&gt; Report.extract_from_dict(sample_data, \"scra\")\n'14 SCRA 314'\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>A <code>dict</code> containing a possible report <code>{key: value}</code></p> required <code>report_type</code> <code>str</code> <p>Must be either \"scra\", \"phil\", or \"offg\"</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: The value of the key <code>report_type</code> in the <code>data</code> dict.</p> Source code in <code>citation_report/__main__.py</code> Python<pre><code>@classmethod\ndef extract_from_dict(cls, data: dict, report_type: str) -&gt; str | None:\n\"\"\"Assuming a dictionary with any of the following report_type keys\n    `scra`, `phil` or `offg`, get the value of the Report property.\n    Examples:\n        &gt;&gt;&gt; sample_data = {\"scra\": \"14 SCRA 314\"} # dict\n        &gt;&gt;&gt; Report.extract_from_dict(sample_data, \"scra\")\n        '14 SCRA 314'\n    Args:\n        data (dict): A `dict` containing a possible report `{key: value}`\n        report_type (str): Must be either \"scra\", \"phil\", or \"offg\"\n    Returns:\n        str | None: The value of the key `report_type` in the `data` dict.\n    \"\"\"\nif report_type.lower() in [\"scra\", \"phil\", \"offg\"]:\nif candidate := data.get(report_type):\ntry:\nobj = next(cls.extract_report(candidate))\n# will get the @property of the Report with the same name\nif hasattr(obj, report_type):\nreturn obj.__getattribute__(report_type)\nexcept StopIteration:\nreturn None\nreturn None\n</code></pre>"},{"location":"report/#citation_report.__main__.Report.extract_report","title":"<code>extract_report(text)</code>  <code>classmethod</code>","text":"<p>Given sample legalese <code>text</code>, extract all Supreme Court <code>Report</code> patterns.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; sample = \"250 Phil. 271, 271-272, Jan. 1, 2019\"\n&gt;&gt;&gt; report = next(Report.extract(sample))\n&gt;&gt;&gt; type(report)\ncitation_report.__main__.Report\n&gt;&gt;&gt; report.volpubpage\n'250 Phil. 271'\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text containing report citations.</p> required <p>Yields:</p> Type Description <code>Iterator[Self]</code> <p>Iterator[Self]: Iterator of <code>Report</code> instances</p> Source code in <code>citation_report/__main__.py</code> Python<pre><code>@classmethod\ndef extract_report(cls, text: str) -&gt; Iterator[Self]:\n\"\"\"Given sample legalese `text`, extract all Supreme Court `Report` patterns.\n    Examples:\n        &gt;&gt;&gt; sample = \"250 Phil. 271, 271-272, Jan. 1, 2019\"\n        &gt;&gt;&gt; report = next(Report.extract(sample))\n        &gt;&gt;&gt; type(report)\n        citation_report.__main__.Report\n        &gt;&gt;&gt; report.volpubpage\n        '250 Phil. 271'\n    Args:\n        text (str): Text containing report citations.\n    Yields:\n        Iterator[Self]: Iterator of `Report` instances\n    \"\"\"\nfor match in REPORT_PATTERN.finditer(text):\nreport_date = None\nif text := match.group(\"report_date\"):\ntry:\nreport_date = parse(text).date()\nexcept Exception:\nreport_date = None\npublisher = get_publisher_label(match)\nvolume = match.group(\"volume\")\npage = match.group(\"page\")\nif publisher and volume and page:\nyield Report(\npublisher=publisher,\nvolume=volume,\npage=page,\nvolpubpage=match.group(\"volpubpage\"),\nreport_date=report_date,\n)\n</code></pre>"},{"location":"report/#citation_report.__main__.Report.get_unique","title":"<code>get_unique(text)</code>  <code>classmethod</code>","text":"<p>Will only get <code>Report</code> volpubpages (string) from the text. This is used later in <code>citation_utils</code> to prevent duplicate citations.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; text = \"(22 Phil. 303; 22 Phil. 303; 176 SCRA 240; Pe\u00f1alosa v. Tuason, 22 Phil. 303, 313 (1912); Heirs of Roxas v. Galido, 108 Phil. 582 (1960)); Valmonte v. PCSO, supra; Bugnay Const. and Dev. Corp. v. Laron, 176 SCRA 240 (1989)\"\n&gt;&gt;&gt; Report.get_unique(text)\n['22 Phil. 303', '108 Phil. 582', '176 SCRA 240']\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text to search for report patterns</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: Unique report <code>volpubpage</code> strings found in the text</p> Source code in <code>citation_report/__main__.py</code> Python<pre><code>@classmethod\ndef get_unique(cls, text: str) -&gt; list[str]:\n\"\"\"Will only get `Report` volpubpages (string) from the text. This\n    is used later in `citation_utils` to prevent duplicate citations.\n    Examples:\n        &gt;&gt;&gt; text = \"(22 Phil. 303; 22 Phil. 303; 176 SCRA 240; Pe\u00f1alosa v. Tuason, 22 Phil. 303, 313 (1912); Heirs of Roxas v. Galido, 108 Phil. 582 (1960)); Valmonte v. PCSO, supra; Bugnay Const. and Dev. Corp. v. Laron, 176 SCRA 240 (1989)\"\n        &gt;&gt;&gt; Report.get_unique(text)\n        ['22 Phil. 303', '108 Phil. 582', '176 SCRA 240']\n    Args:\n        text (str): Text to search for report patterns\n    Returns:\n        list[str]: Unique report `volpubpage` strings found in the text\n    \"\"\"  # noqa: E501\nreturn list(\n{r.volpubpage for r in cls.extract_report(text) if r.volpubpage}\n)\n</code></pre>"}]}