{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Citation Report","text":""},{"location":"#concepts","title":"Concepts","text":""},{"location":"#definition","title":"Definition","text":"<p>There are three popular repositories of Philippine Supreme Court decisions. Reference to such decisions are (traditionally) based on the name of the repository. Two of which - <code>Phil.</code> and <code>SCRA</code> - are talked about in the case of China Airlines v. Chiok, G.R. No. 152122, July 30, 2003:</p> <p>x x x This Court hereby exhorts members of the bar and the bench to refer to and quote from the official repository of our decisions, the Philippine Reports, whenever practicable [footnote: In the present case, Philippine Reports are cited whenever possible.]. In the absence of this primary source, which is still being updated, they may resort to unofficial sources like the SCRA [footnote: Supreme Court Reports Annotated]. We remind them that the Court\u2019s ponencia, when used to support a judgment or ruling, should be quoted accurately. (emphasis and footnotes supplied)</p>"},{"location":"#kinds","title":"Kinds","text":"Style Nature Publisher Description Basis <code>Phil.</code> Public Philippine Reports Though \"official\", often delayed in publication The [Supreme Court] Reporter shall prepare and publish with each reported decision a concise synopsis of the facts necessary to a clear understanding of the case x x x <code>Offg.</code> Public Official Gazette Though \"official\", decisions are only published here occasionally There shall be published in the Official Gazette all x x x decisions or abstracts of decisions of the Supreme Court and the Court of Appeals, or other courts of similar rank, as may be deemed by the said courts of sufficient importance to be so published; x x x <code>SCRA</code> Private Supreme Court Reports Annotated An unofficial source but more frequently printed by private entity See disquisition in China Airlines v. Chiok (2003)"},{"location":"#formats","title":"Formats","text":"<p>Each of the Report citations above have the same format... differing only in the <code>publisher</code> involved. Because of inconsistent styling over the years -- e.g. instead of Phil., what will be written is Phil Rep. -- it's necessary to create a uniform format using a <code>volume</code> <code>publisher</code> <code>page</code> format:</p> Volume Publisher Page/s Date Sample Inconsistencies Volume no. Name / style of the publisher / reporter Page number/s of the volume Optional date 1 Phil. Reports 100 is equivalent to 1 Phil. 100 1 <code>Phil.</code> 100 - 100 S.C.R.A. 105, 101-103 (1994) is equivalent to 100 SCRA 105 1 <code>SCRA</code> 105 - 41 Off. Gazette 1001, Jan. 1, 1949 is equivalent to 41 O.G. 1001 41 <code>O.G.</code> 1001 Jan. 1, 1949"},{"location":"#api","title":"API","text":""},{"location":"#report-model","title":"Report Model","text":"<p>               Bases: <code>BaseModel</code></p> <p>The <code>REPORT_PATTERN</code> is a <code>re.Pattern</code> object that contains pre-defined regex group names. These group names can be mapped to the <code>Report</code> model's fields:</p> Field Type Description <code>publisher</code> optional (str) Type of the publisher. <code>volume</code> optional (str) Publisher volume number. <code>page</code> optional (str) Publisher volume page. <code>volpubpage</code> optional (str) Combined fields:  <code>report_date</code> optional (date) Optional date associated with the report citation <p>It's important that each field be optional. The <code>Report</code> will be joined to another <code>BaseModel</code> object, i.e. the <code>Docket</code>, in a third-party library. It must be stressed that the <code>Report</code> object is only one part of the eventual <code>DockerReportCitation</code> object. It can:</p> <ol> <li>have both a <code>Docket</code> and a <code>Report</code>,</li> <li>have just a <code>Docket</code>;</li> <li>have just a <code>Report</code>.</li> </ol> <p>If the value of the property exists, it represents whole <code>@volpubpage</code> value.</p> <ol> <li><code>@phil</code></li> <li><code>@scra</code></li> <li><code>@offg</code></li> </ol> Source code in <code>src/citation_report/main.py</code> Python<pre><code>class Report(BaseModel):\n    \"\"\"The `REPORT_PATTERN` is a `re.Pattern` object that\n    contains pre-defined regex group names. These group names can be mapped\n    to the `Report` model's fields:\n\n    Field | Type | Description\n    --:|:--:|:--\n    `publisher` | optional (str) | Type of the publisher.\n    `volume` | optional (str) | Publisher volume number.\n    `page` | optional (str) | Publisher volume page.\n    `volpubpage` | optional (str) | Combined fields: &lt;volume&gt; &lt;publisher&gt; &lt;page&gt;\n    `report_date` | optional (date) | Optional date associated with the report citation\n\n    It's important that each field be **optional**. The `Report` will be joined\n    to another `BaseModel` object, i.e. the `Docket`, in a third-party library.\n    It must be stressed that the `Report` object is only one part of\n    the eventual `DockerReportCitation` object. It can:\n\n    1. have both a `Docket` and a `Report`,\n    2. have just a `Docket`;\n    3. have just a `Report`.\n\n    If the value of the property exists, it represents whole `@volpubpage` value.\n\n    1. `@phil`\n    2. `@scra`\n    3. `@offg`\n    \"\"\"\n\n    model_config = ConfigDict(str_strip_whitespace=True)\n\n    publisher: str | None = Field(default=None, max_length=5)\n    volume: str | None = Field(\n        default=None,\n        description=\"Can exceptionally include letters e.g. vol 1a\",\n        max_length=10,\n    )\n    page: str | None = Field(\n        default=None,\n        description=\"Page number can have letters, e.g. 241a\",\n        max_length=5,\n    )\n    report_date: datetime.date | None = Field(\n        default=None,\n        description=\"Exceptionally, report citations reference dates.\",\n    )\n\n    @field_validator(\"publisher\")\n    def publisher_limited_to_phil_scra_offg(cls, v):\n        options = (ReportPhil.label, ReportSCRA.label, ReportOffg.label)\n        if v and v not in options:\n            raise ValueError(f\"not allowed in {options=}\")\n        return v\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;Report {self.volpubpage}&gt;\"\n\n    def __str__(self) -&gt; str:\n        return self.volpubpage or \"\"\n\n    def __eq__(self, other: Self) -&gt; bool:\n        \"\"\"Naive equality checks will only compare direct values,\n        exceptionally, when volume, publisher and page are provided,\n        must compare all three values with each other.\n\n        Examples:\n            &gt;&gt;&gt; a = Report(volume='10', publisher='Phil.', page='25')\n            &gt;&gt;&gt; b = Report(volume='10', publisher='Phil.')\n            &gt;&gt;&gt; a == b\n            False\n            &gt;&gt;&gt; c = Report(volume='10', publisher='SCRA', page='25')\n            &gt;&gt;&gt; a == c\n            False\n            &gt;&gt;&gt; d = Report(volume='10', publisher='Phil.', page='25')\n            &gt;&gt;&gt; a == d\n            True\n\n        Args:\n            other (Self): The other Report instance to compare.\n\n        Returns:\n            bool: Whether values are equal\n        \"\"\"\n        opt_1 = is_eq(self.phil, other.phil)\n        opt_2 = is_eq(self.scra, other.scra)\n        opt_3 = is_eq(self.offg, other.offg)\n        opt_4 = all(\n            [\n                is_eq(self.publisher, other.publisher),\n                is_eq(self.volume, other.volume),\n                is_eq(self.page, other.page),\n            ]\n        )\n        return any([opt_1, opt_2, opt_3, opt_4])\n\n    @property\n    def phil(self):\n        return (\n            f\"{self.volume} {ReportPhil.label} {self.page}\"\n            if self.publisher == ReportPhil.label\n            else None\n        )\n\n    @property\n    def scra(self):\n        return (\n            f\"{self.volume} {ReportSCRA.label} {self.page}\"\n            if self.publisher == ReportSCRA.label\n            else None\n        )\n\n    @property\n    def offg(self):\n        return (\n            f\"{self.volume} {ReportOffg.label} {self.page}\"\n            if self.publisher == ReportOffg.label\n            else None\n        )\n\n    @property\n    def volpubpage(self):\n        return self.phil or self.scra or self.offg\n\n    @classmethod\n    def extract_reports(cls, text: str) -&gt; Iterator[\"Report\"]:\n        \"\"\"Given sample legalese `text`, extract all Supreme Court `Report` patterns.\n\n        Examples:\n            &gt;&gt;&gt; sample = \"250 Phil. 271, 271-272, Jan. 1, 2019\"\n            &gt;&gt;&gt; report = next(Report.extract_reports(sample))\n            &gt;&gt;&gt; type(report)\n            &lt;class 'citation_report.main.Report'&gt;\n            &gt;&gt;&gt; report.volpubpage\n            '250 Phil. 271'\n            &gt;&gt;&gt; unnormalized = \"50\\xa0 Off. Gaz.,\\xa0 583\"\n            &gt;&gt;&gt; report1 = next(Report.extract_reports(unnormalized))\n            &gt;&gt;&gt; report1.volpubpage\n            '50 O.G. 583'\n\n        Args:\n            text (str): Text containing report citations.\n\n        Yields:\n            Iterator[\"Report\"]: Iterator of `Report` instances\n        \"\"\"\n        text = unicodedata.normalize(\"NFKD\", text)\n        for match in REPORT_PATTERN.finditer(text):\n            report_date = None\n            if text := match.group(\"report_date\"):\n                try:\n                    report_date = parse(text).date()\n                except Exception:\n                    report_date = None\n\n            publisher = get_publisher_label(match)\n            volume = match.group(\"volume\")\n            page = match.group(\"page\")\n\n            if publisher and volume and page:\n                yield Report(\n                    publisher=publisher,\n                    volume=volume,\n                    page=page,\n                    report_date=report_date,\n                )\n\n    @classmethod\n    def extract_from_dict(cls, data: dict, report_type: str) -&gt; str | None:\n        \"\"\"Assuming a dictionary with any of the following report_type keys\n        `scra`, `phil` or `offg`, get the value of the Report property.\n\n        Examples:\n            &gt;&gt;&gt; sample_data = {\"scra\": \"14 SCRA 314\"} # dict\n            &gt;&gt;&gt; Report.extract_from_dict(sample_data, \"scra\")\n            '14 SCRA 314'\n\n        Args:\n            data (dict): A `dict` containing a possible report `{key: value}`\n            report_type (str): Must be either \"scra\", \"phil\", or \"offg\"\n\n        Returns:\n            str | None: The value of the key `report_type` in the `data` dict.\n        \"\"\"\n        if report_type.lower() in [\"scra\", \"phil\", \"offg\"]:\n            if candidate := data.get(report_type):\n                try:\n                    obj = next(cls.extract_reports(candidate))\n                    # will get the @property of the Report with the same name\n                    if hasattr(obj, report_type):\n                        return obj.__getattribute__(report_type)\n                except StopIteration:\n                    return None\n        return None\n\n    @classmethod\n    def get_unique(cls, text: str) -&gt; list[str]:\n        \"\"\"Will only get `Report` volpubpages (string) from the text. This\n        is used later in `citation_utils` to prevent duplicate citations.\n\n        Examples:\n            &gt;&gt;&gt; text = \"(22 Phil. 303; 22 Phil. 303; 176 SCRA 240; Pe\u00f1alosa v. Tuason, 22 Phil. 303, 313 (1912); Heirs of Roxas v. Galido, 108 Phil. 582 (1960)); Valmonte v. PCSO, supra; Bugnay Const. and Dev. Corp. v. Laron, 176 SCRA 240 (1989)\"\n            &gt;&gt;&gt; len(Report.get_unique(text))\n            3\n            &gt;&gt;&gt; set(Report.get_unique(text)) == {'22 Phil. 303', '176 SCRA 240', '108 Phil. 582'}\n            True\n\n        Args:\n            text (str): Text to search for report patterns\n\n        Returns:\n            list[str]: Unique report `volpubpage` strings found in the text\n        \"\"\"  # noqa: E501\n        return list({r.volpubpage for r in cls.extract_reports(text) if r.volpubpage})\n</code></pre>"},{"location":"#citation_report.Report-functions","title":"Functions","text":""},{"location":"#citation_report.Report.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Naive equality checks will only compare direct values, exceptionally, when volume, publisher and page are provided, must compare all three values with each other.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; a = Report(volume='10', publisher='Phil.', page='25')\n&gt;&gt;&gt; b = Report(volume='10', publisher='Phil.')\n&gt;&gt;&gt; a == b\nFalse\n&gt;&gt;&gt; c = Report(volume='10', publisher='SCRA', page='25')\n&gt;&gt;&gt; a == c\nFalse\n&gt;&gt;&gt; d = Report(volume='10', publisher='Phil.', page='25')\n&gt;&gt;&gt; a == d\nTrue\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>The other Report instance to compare.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether values are equal</p> Source code in <code>src/citation_report/main.py</code> Python<pre><code>def __eq__(self, other: Self) -&gt; bool:\n    \"\"\"Naive equality checks will only compare direct values,\n    exceptionally, when volume, publisher and page are provided,\n    must compare all three values with each other.\n\n    Examples:\n        &gt;&gt;&gt; a = Report(volume='10', publisher='Phil.', page='25')\n        &gt;&gt;&gt; b = Report(volume='10', publisher='Phil.')\n        &gt;&gt;&gt; a == b\n        False\n        &gt;&gt;&gt; c = Report(volume='10', publisher='SCRA', page='25')\n        &gt;&gt;&gt; a == c\n        False\n        &gt;&gt;&gt; d = Report(volume='10', publisher='Phil.', page='25')\n        &gt;&gt;&gt; a == d\n        True\n\n    Args:\n        other (Self): The other Report instance to compare.\n\n    Returns:\n        bool: Whether values are equal\n    \"\"\"\n    opt_1 = is_eq(self.phil, other.phil)\n    opt_2 = is_eq(self.scra, other.scra)\n    opt_3 = is_eq(self.offg, other.offg)\n    opt_4 = all(\n        [\n            is_eq(self.publisher, other.publisher),\n            is_eq(self.volume, other.volume),\n            is_eq(self.page, other.page),\n        ]\n    )\n    return any([opt_1, opt_2, opt_3, opt_4])\n</code></pre>"},{"location":"#citation_report.Report.extract_from_dict","title":"<code>extract_from_dict(data, report_type)</code>  <code>classmethod</code>","text":"<p>Assuming a dictionary with any of the following report_type keys <code>scra</code>, <code>phil</code> or <code>offg</code>, get the value of the Report property.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; sample_data = {\"scra\": \"14 SCRA 314\"} # dict\n&gt;&gt;&gt; Report.extract_from_dict(sample_data, \"scra\")\n'14 SCRA 314'\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>A <code>dict</code> containing a possible report <code>{key: value}</code></p> required <code>report_type</code> <code>str</code> <p>Must be either \"scra\", \"phil\", or \"offg\"</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: The value of the key <code>report_type</code> in the <code>data</code> dict.</p> Source code in <code>src/citation_report/main.py</code> Python<pre><code>@classmethod\ndef extract_from_dict(cls, data: dict, report_type: str) -&gt; str | None:\n    \"\"\"Assuming a dictionary with any of the following report_type keys\n    `scra`, `phil` or `offg`, get the value of the Report property.\n\n    Examples:\n        &gt;&gt;&gt; sample_data = {\"scra\": \"14 SCRA 314\"} # dict\n        &gt;&gt;&gt; Report.extract_from_dict(sample_data, \"scra\")\n        '14 SCRA 314'\n\n    Args:\n        data (dict): A `dict` containing a possible report `{key: value}`\n        report_type (str): Must be either \"scra\", \"phil\", or \"offg\"\n\n    Returns:\n        str | None: The value of the key `report_type` in the `data` dict.\n    \"\"\"\n    if report_type.lower() in [\"scra\", \"phil\", \"offg\"]:\n        if candidate := data.get(report_type):\n            try:\n                obj = next(cls.extract_reports(candidate))\n                # will get the @property of the Report with the same name\n                if hasattr(obj, report_type):\n                    return obj.__getattribute__(report_type)\n            except StopIteration:\n                return None\n    return None\n</code></pre>"},{"location":"#citation_report.Report.extract_reports","title":"<code>extract_reports(text)</code>  <code>classmethod</code>","text":"<p>Given sample legalese <code>text</code>, extract all Supreme Court <code>Report</code> patterns.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; sample = \"250 Phil. 271, 271-272, Jan. 1, 2019\"\n&gt;&gt;&gt; report = next(Report.extract_reports(sample))\n&gt;&gt;&gt; type(report)\n&lt;class 'citation_report.main.Report'&gt;\n&gt;&gt;&gt; report.volpubpage\n'250 Phil. 271'\n&gt;&gt;&gt; unnormalized = \"50\u00a0 Off. Gaz.,\u00a0 583\"\n&gt;&gt;&gt; report1 = next(Report.extract_reports(unnormalized))\n&gt;&gt;&gt; report1.volpubpage\n'50 O.G. 583'\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text containing report citations.</p> required <p>Yields:</p> Type Description <code>Report</code> <p>Iterator[\"Report\"]: Iterator of <code>Report</code> instances</p> Source code in <code>src/citation_report/main.py</code> Python<pre><code>@classmethod\ndef extract_reports(cls, text: str) -&gt; Iterator[\"Report\"]:\n    \"\"\"Given sample legalese `text`, extract all Supreme Court `Report` patterns.\n\n    Examples:\n        &gt;&gt;&gt; sample = \"250 Phil. 271, 271-272, Jan. 1, 2019\"\n        &gt;&gt;&gt; report = next(Report.extract_reports(sample))\n        &gt;&gt;&gt; type(report)\n        &lt;class 'citation_report.main.Report'&gt;\n        &gt;&gt;&gt; report.volpubpage\n        '250 Phil. 271'\n        &gt;&gt;&gt; unnormalized = \"50\\xa0 Off. Gaz.,\\xa0 583\"\n        &gt;&gt;&gt; report1 = next(Report.extract_reports(unnormalized))\n        &gt;&gt;&gt; report1.volpubpage\n        '50 O.G. 583'\n\n    Args:\n        text (str): Text containing report citations.\n\n    Yields:\n        Iterator[\"Report\"]: Iterator of `Report` instances\n    \"\"\"\n    text = unicodedata.normalize(\"NFKD\", text)\n    for match in REPORT_PATTERN.finditer(text):\n        report_date = None\n        if text := match.group(\"report_date\"):\n            try:\n                report_date = parse(text).date()\n            except Exception:\n                report_date = None\n\n        publisher = get_publisher_label(match)\n        volume = match.group(\"volume\")\n        page = match.group(\"page\")\n\n        if publisher and volume and page:\n            yield Report(\n                publisher=publisher,\n                volume=volume,\n                page=page,\n                report_date=report_date,\n            )\n</code></pre>"},{"location":"#citation_report.Report.get_unique","title":"<code>get_unique(text)</code>  <code>classmethod</code>","text":"<p>Will only get <code>Report</code> volpubpages (string) from the text. This is used later in <code>citation_utils</code> to prevent duplicate citations.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; text = \"(22 Phil. 303; 22 Phil. 303; 176 SCRA 240; Pe\u00f1alosa v. Tuason, 22 Phil. 303, 313 (1912); Heirs of Roxas v. Galido, 108 Phil. 582 (1960)); Valmonte v. PCSO, supra; Bugnay Const. and Dev. Corp. v. Laron, 176 SCRA 240 (1989)\"\n&gt;&gt;&gt; len(Report.get_unique(text))\n3\n&gt;&gt;&gt; set(Report.get_unique(text)) == {'22 Phil. 303', '176 SCRA 240', '108 Phil. 582'}\nTrue\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text to search for report patterns</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: Unique report <code>volpubpage</code> strings found in the text</p> Source code in <code>src/citation_report/main.py</code> Python<pre><code>@classmethod\ndef get_unique(cls, text: str) -&gt; list[str]:\n    \"\"\"Will only get `Report` volpubpages (string) from the text. This\n    is used later in `citation_utils` to prevent duplicate citations.\n\n    Examples:\n        &gt;&gt;&gt; text = \"(22 Phil. 303; 22 Phil. 303; 176 SCRA 240; Pe\u00f1alosa v. Tuason, 22 Phil. 303, 313 (1912); Heirs of Roxas v. Galido, 108 Phil. 582 (1960)); Valmonte v. PCSO, supra; Bugnay Const. and Dev. Corp. v. Laron, 176 SCRA 240 (1989)\"\n        &gt;&gt;&gt; len(Report.get_unique(text))\n        3\n        &gt;&gt;&gt; set(Report.get_unique(text)) == {'22 Phil. 303', '176 SCRA 240', '108 Phil. 582'}\n        True\n\n    Args:\n        text (str): Text to search for report patterns\n\n    Returns:\n        list[str]: Unique report `volpubpage` strings found in the text\n    \"\"\"  # noqa: E501\n    return list({r.volpubpage for r in cls.extract_reports(text) if r.volpubpage})\n</code></pre>"},{"location":"#report-pattern","title":"Report Pattern","text":"<p>A compiled regex expression that enables capturing the parts of a report.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from citation_report import REPORT_PATTERN\n&gt;&gt;&gt; text = \"42 SCRA 109, 117-118, October 29, 1971;\"\n&gt;&gt;&gt; sample_match = REPORT_PATTERN.search(text)\n&gt;&gt;&gt; sample_match.group(\"volpubpage\")\n'42 SCRA 109'\n&gt;&gt;&gt; sample_match.group(\"volume\")\n'42 SCRA 109'\n&gt;&gt;&gt; sample_match.group(\"publisher\")\n'SCRA'\n&gt;&gt;&gt; sample_match.group(\"page\")\n'109'\n&gt;&gt;&gt; sample_match.group(\"REPORT_DATE_REGEX\")\n'October 29, 1971'\n</code></pre>"},{"location":"#get_publisher_label","title":"get_publisher_label()","text":"<p>Given a regex match object from <code>REPORT_PATTERN</code>, determine if it contains a group name representing a Report publisher.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from citation_report import REPORT_PATTERN, get_publisher_label\n&gt;&gt;&gt; assert REPORT_PATTERN.search(\"124Phil.1241 statement\") is None\n&gt;&gt;&gt; sample = \"This is an example 124 Phil. 1241 statement\"\n&gt;&gt;&gt; m = REPORT_PATTERN.search(sample)\n&gt;&gt;&gt; m\n&lt;re.Match object; span=(19, 33), match='124 Phil. 1241'&gt;\n&gt;&gt;&gt; label = get_publisher_label(m)\n&gt;&gt;&gt; label\n'Phil.'\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>match</code> <code>Match</code> <p>Based on a prior <code>re.search</code> or <code>re.finditer</code> result on text</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: The first matching publisher found</p> Source code in <code>src/citation_report/publisher.py</code> Python<pre><code>def get_publisher_label(match: Match) -&gt; str | None:\n    \"\"\"Given a regex match object from `REPORT_PATTERN`,\n    determine if it contains a group name representing a Report publisher.\n\n    Examples:\n        &gt;&gt;&gt; from citation_report import REPORT_PATTERN, get_publisher_label\n        &gt;&gt;&gt; assert REPORT_PATTERN.search(\"124Phil.1241 statement\") is None\n        &gt;&gt;&gt; sample = \"This is an example 124 Phil. 1241 statement\"\n        &gt;&gt;&gt; m = REPORT_PATTERN.search(sample)\n        &gt;&gt;&gt; m\n        &lt;re.Match object; span=(19, 33), match='124 Phil. 1241'&gt;\n        &gt;&gt;&gt; label = get_publisher_label(m)\n        &gt;&gt;&gt; label\n        'Phil.'\n\n    Args:\n        match (Match): Based on a prior `re.search` or `re.finditer`\n            result on text\n\n    Returns:\n        str | None: The first matching publisher found\n    \"\"\"\n    for src in [ReportPhil, ReportSCRA, ReportOffg]:\n        if match.group(src.group_name):\n            return src.label\n</code></pre>"}]}